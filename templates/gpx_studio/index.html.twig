{% extends 'base.html.twig' %}
{% block title %}GPX Studio{% endblock %}

{% block body %}
<div class="container-fluid py-3">
  <div class="row g-3">
    <div class="col-12 col-lg-3">
      <div class="card shadow-sm">
        <div class="card-body">
          <h5 class="card-title mb-3">GPX Studio</h5>

          <div class="mb-3">
            <label class="form-label">Profil (ORS)</label>
            <select id="profile" class="form-select">
              <option value="driving-car" {{ default_profile=='driving-car'?'selected':'' }}>Fahrzeug</option>
              <option value="cycling-regular" {{ default_profile=='cycling-regular'?'selected':'' }}>Rad</option>
              <option value="foot-walking" {{ default_profile=='foot-walking'?'selected':'' }}>Fuß</option>
            </select>
          </div>

          <div class="mb-3">
            <div class="form-check form-switch">
              <input class="form-check-input" type="checkbox" id="snapToggle" checked>
              <label class="form-check-label" for="snapToggle">Auf Straßennetz snappen (ORS)</label>
            </div>
          </div>

          <div class="mb-3">
            <label class="form-label">Vereinfachen (m)</label>
            <input id="simplify" type="number" class="form-control" min="0" step="1" value="0">
            <div class="form-text">0 = aus. Douglas–Peucker auf Track (Anzeige/Export).</div>
          </div>

          <div class="d-grid gap-2 mb-3">
            <button id="btn-draw" class="btn btn-primary"><i class="bi bi-pencil"></i> Zeichnen</button>
            <button id="btn-move" class="btn btn-outline-primary"><i class="bi bi-arrows-move"></i> Wegpunkte verschieben</button>
            <button id="btn-clear" class="btn btn-outline-danger"><i class="bi bi-trash"></i> Alles löschen</button>
          </div>

          <div class="d-grid gap-2 mb-3">
            <label class="form-label">GPX-Datei importieren</label>
            <input id="gpx-file" type="file" class="form-control" accept=".gpx,application/gpx+xml">
            <button id="btn-export" class="btn btn-success fw-bold"><i class="bi bi-file-earmark-arrow-down"></i> Als GPX exportieren</button>
          </div>

          <div class="border rounded p-2 small">
            <div><strong>Distanz:</strong> <span id="stat-distance">–</span></div>
            <div><strong>Geschätzt Dauer:</strong> <span id="stat-duration">–</span></div>
            <div><strong>Punkte:</strong> <span id="stat-points">0</span></div>
          </div>

          <hr/>
          <div class="small text-muted">
            Tipp: Klicken fügt Wegpunkt hinzu (Zeichenmodus). Ziehen zum Verschieben (Verschieben-Modus).
            Bei aktivem ORS-Snap werden Teilstücke automatisch berechnet.
          </div>
        </div>
      </div>
    </div>

    <div class="col-12 col-lg-9">
      <div id="map" style="height: 78vh; border-radius: 12px;"></div>
    </div>
  </div>
</div>

<link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

<script>
(() => {
  const STYLE_URL = '{{ tiles_style_url }}';
  const ORS_PROXY = '{{ path("app_gpx_studio_ors_directions") }}';
  const ORS_MATCH = '{{ path("app_gpx_studio_ors_match") }}';

  const map = new maplibregl.Map({
    container: 'map',
    style: STYLE_URL,
    center: [6.62, 51.65],
    zoom: 12
  });

  let mode = 'draw';
  let snapEnabled = true;
  let profile = document.getElementById('profile').value;

  let waypoints = [];   // [{lng,lat, marker}]
  let trackCoords = []; // [[lng,lat], ...]

  map.on('load', () => {
    map.addSource('track', { type: 'geojson', data: emptyFC() });
    map.addLayer({ id: 'track-line', type: 'line', source: 'track',
      paint: { 'line-width': 4, 'line-color': '#ff2d55' } });

    map.addSource('wpts', { type: 'geojson', data: emptyFC() });
    map.addLayer({ id: 'wpt-circles', type: 'circle', source: 'wpts',
      paint: { 'circle-radius': 5, 'circle-color': '#1f7aec', 'circle-stroke-color': '#fff', 'circle-stroke-width': 2 } });
  });

  // UI
  document.getElementById('profile').addEventListener('change', (e) => {
    profile = e.target.value;
    if (snapEnabled && waypoints.length >= 2) recalcSnapped();
  });
  document.getElementById('snapToggle').addEventListener('change', (e) => {
    snapEnabled = e.target.checked;
    recalcDisplayed();
  });
  document.getElementById('simplify').addEventListener('change', () => recalcDisplayed());

  document.getElementById('btn-draw').addEventListener('click', () => setMode('draw'));
  document.getElementById('btn-move').addEventListener('click', () => setMode('move'));
  document.getElementById('btn-clear').addEventListener('click', clearAll);
  document.getElementById('btn-export').addEventListener('click', exportGPX);
  document.getElementById('gpx-file').addEventListener('change', importGPX);

  function setMode(m){
    mode = m;
    document.getElementById('btn-draw').classList.toggle('btn-primary', mode==='draw');
    document.getElementById('btn-draw').classList.toggle('btn-outline-primary', mode!=='draw');
    document.getElementById('btn-move').classList.toggle('btn-primary', mode==='move');
    document.getElementById('btn-move').classList.toggle('btn-outline-primary', mode!=='move');
  }

  // === Interaktionen ===
  map.on('click', async (e) => {
    if (mode !== 'draw') return;
    let lng = e.lngLat.lng, lat = e.lngLat.lat;

    // Beim Setzen sofort aufs Netz snappen (gegen den vorigen Punkt)
    if (snapEnabled && waypoints.length >= 1) {
      const prev = waypoints[waypoints.length - 1];
      const snapped = await snapBetween([prev.lng, prev.lat], [lng, lat]).catch(()=>null);
      if (snapped) { lng = snapped[0]; lat = snapped[1]; }
    }

    addWaypoint(lng, lat, true);
  });

  function addWaypoint(lng, lat, reroute = false) {
    const marker = new maplibregl.Marker({ draggable: true })
      .setLngLat([lng, lat]).addTo(map);

    marker.on('dragstart', () => setMode('move'));
    marker.on('dragend', async () => {
      const ll = marker.getLngLat();
      const idx = waypoints.findIndex(w => w.marker === marker);
      if (idx < 0) return;

      let newLng = ll.lng, newLat = ll.lat;

      if (snapEnabled) {
        if (waypoints.length === 1) {
          // nur ein Punkt → nichts zum „zwischen“ snappen
        } else if (idx === 0) {
          // erster Punkt: gegen rechten Nachbarn snappen
          const right = waypoints[1];
          const snapped = await snapBetween([ll.lng, ll.lat], [right.lng, right.lat]).catch(()=>null);
          if (snapped) { newLng = snapped[0]; newLat = snapped[1]; }
        } else if (idx === waypoints.length - 1) {
          // letzter Punkt: gegen linken Nachbarn snappen
          const left = waypoints[idx - 1];
          const snapped = await snapBetween([left.lng, left.lat], [ll.lng, ll.lat]).catch(()=>null);
          if (snapped) { newLng = snapped[0]; newLat = snapped[1]; }
        } else {
          // innerer Punkt: prev → dragged → next routen und auf Linie projizieren
          const left  = waypoints[idx - 1];
          const right = waypoints[idx + 1];
          const geom = await orsRoute(profile, [[left.lng,left.lat],[ll.lng,ll.lat],[right.lng,right.lat]]).catch(()=>null);
          if (geom && geom.length >= 2) {
            const snappedOnLine = nearestOnLine(geom, [ll.lng, ll.lat]);
            if (snappedOnLine) { newLng = snappedOnLine[0]; newLat = snappedOnLine[1]; }
          }
        }
      }

      waypoints[idx].lng = newLng;
      waypoints[idx].lat = newLat;
      marker.setLngLat([newLng, newLat]);

      if (snapEnabled) recalcSnapped(); else rebuildTrackFromWaypoints();
    });

    waypoints.push({ lng, lat, marker });
    updateWptSource();

    if (reroute) {
      if (snapEnabled) recalcSnapped();
      else rebuildTrackFromWaypoints();
    }
  }

  function updateWptSource() {
    const src = map.getSource('wpts');
    const fc = { type:'FeatureCollection', features: waypoints.map(w => ({
      type:'Feature', geometry:{ type:'Point', coordinates:[w.lng,w.lat] }, properties:{}
    }))};
    if (src) src.setData(fc);
    document.getElementById('stat-points').innerText = String(trackCoords.length);
  }

  // === Routing / Snapping ===
  async function snapBetween(a, b) {
    const line = await orsRoute(profile, [a, b]);
    return line?.length ? line[line.length - 1] : null;
  }

  async function recalcSnapped() {
    if (waypoints.length < 2) {
      setTrack(waypoints.map(w => [w.lng, w.lat]));
      return;
    }
    const coords = waypoints.map(w => [w.lng, w.lat]);
    try {
      const snapped = await orsRoute(profile, coords);
      setTrack(snapped || coords);
    } catch (e) {
      console.error('ORS failed', e);
      rebuildTrackFromWaypoints();
    }
  }

  function rebuildTrackFromWaypoints() {
    setTrack(waypoints.map(w => [w.lng, w.lat]));
  }

  async function orsRoute(profile, coords) {
    const res = await fetch(ORS_PROXY, {
      method: 'POST',
      credentials: 'same-origin',
      headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
      body: JSON.stringify({ profile, coordinates: coords })
    });
    if (!res.ok) throw new Error('ORS HTTP ' + res.status);
    const j = await res.json();
    const g = j?.features?.[0]?.geometry;
    if (!g || g.type!=='LineString') throw new Error('ORS response invalid');
    return g.coordinates;
  }

  function setTrack(coords) {
    const tol = Number(document.getElementById('simplify').value || '0');
    trackCoords = (tol > 0 && coords.length > 2) ? douglasPeucker(coords, tol) : coords;

    const src = map.getSource('track');
    if (src) src.setData(coordsToFC(trackCoords));

    const dist = distanceMeters(trackCoords);
    document.getElementById('stat-distance').innerText = (dist/1000).toFixed(2) + ' km';
    const avgKmh = (profile==='foot-walking') ? 4.5 : (profile==='cycling-regular' ? 18 : 30);
    const durSec = dist/1000 / avgKmh * 3600;
    document.getElementById('stat-duration').innerText = fmtDur(durSec);

    fitToTrack();
    updateWptSource();
  }

  function recalcDisplayed() {
    if (snapEnabled) recalcSnapped(); else rebuildTrackFromWaypoints();
  }

  function clearAll() {
    waypoints.forEach(w => w.marker.remove());
    waypoints = [];
    setTrack([]);
  }

  function fitToTrack() {
    if (trackCoords.length < 2) return;
    const b = trackCoords.reduce((bb, c) => bb.extend(c), new maplibregl.LngLatBounds(trackCoords[0], trackCoords[0]));
    map.fitBounds(b, { padding: 60, duration: 400 });
  }

  // === Import / Match ===
  async function importGPX(e) {
    const file = e.target.files?.[0];
    if (!file) return;
    const text = await file.text();
    const xml = new DOMParser().parseFromString(text, 'application/xml');
    const pts = Array.from(xml.getElementsByTagName('trkpt'));
    if (!pts.length) { alert('Keine Trackpunkte gefunden.'); return; }

    let coords = pts.map(p => [parseFloat(p.getAttribute('lon')), parseFloat(p.getAttribute('lat'))]);

    // Map-Matching: Track aufs Straßennetz kleben
    try {
      const matched = await orsMatch(profile, coords);
      if (matched && matched.length >= 2) coords = matched;
    } catch (err) {
      console.warn('Matching fehlgeschlagen, nutze Rohdaten', err);
    }

    clearAll();

    // Wegpunkte grob (Start/Ende + bis zu 20 Zwischenpunkte)
    const W = Math.min(20, Math.max(0, Math.floor(coords.length/50)));
    const idxs = [0];
    for (let i=1;i<=W;i++) idxs.push(Math.floor(i * (coords.length-1)/(W+1)));
    idxs.push(coords.length-1);
    const uniq = Array.from(new Set(idxs)).sort((a,b)=>a-b);

    // Wegpunkte direkt auf Netz (durch Matching)
    for (const i of uniq) addWaypoint(coords[i][0], coords[i][1], false);

    setTrack(coords);
  }

  async function orsMatch(profile, coords) {
    const res = await fetch(ORS_MATCH, {
      method: 'POST',
      credentials: 'same-origin',
      headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
      body: JSON.stringify({ profile, coordinates: coords })
    });
    if (!res.ok) throw new Error('ORS MATCH HTTP ' + res.status);
    const j = await res.json();
    const g = j?.features?.[0]?.geometry;
    if (!g || g.type!=='LineString') throw new Error('MATCH response invalid');
    return g.coordinates;
  }

  // === Export ===
  function exportGPX() {
    if (trackCoords.length < 2) {
      alert('Kein Track zum Exportieren.'); return;
    }
    const gpx = buildGPX(trackCoords);
    const blob = new Blob([gpx], {type:'application/gpx+xml'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'route.gpx';
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href), 0);
  }

  function buildGPX(coords){
    // einfache Zeitstempel (jetzt) pro Punkt – GPX ist happy
    const now = new Date().toISOString();
    const esc = (s)=>String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    const trkpts = coords.map(c =>
      `<trkpt lat="${c[1].toFixed(6)}" lon="${c[0].toFixed(6)}"><time>${now}</time></trkpt>`
    ).join('');
    return `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Tekath-GPX-Studio" xmlns="http://www.topografix.com/GPX/1/1">
  <trk>
    <name>${esc('Route')}</name>
    <trkseg>
      ${trkpts}
    </trkseg>
  </trk>
</gpx>`;
  }

  // === Geometrie-Utils ===
  function emptyFC(){ return {type:'FeatureCollection',features:[]}; }
  function coordsToFC(coords){
    return coords.length>=2 ? {type:'FeatureCollection',features:[{type:'Feature',geometry:{type:'LineString',coordinates:coords},properties:{}}]} : emptyFC();
  }
  function fmtDur(s){ s=Math.round(s); const h=Math.floor(s/3600),m=Math.floor((s%3600)/60),sec=s%60; return h?`${h}h ${m}m`: (m?`${m}m ${sec}s`:`${sec}s`); }
  function distanceMeters(coords){
    let d=0; for(let i=1;i<coords.length;i++) d+=hav(coords[i-1][1],coords[i-1][0], coords[i][1],coords[i][0]); return d;
  }
  function hav(lat1,lon1,lat2,lon2){
    const R=6371000,toRad=d=>d*Math.PI/180; const dLat=toRad(lat2-lat1),dLon=toRad(lon2-lon1);
    const a=Math.sin(dLat/2)**2+Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2; return 2*R*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
  }
  // Douglas–Peucker (Meter-Approx)
  function douglasPeucker(coords, eps){
    if (coords.length<=2) return coords;
    const proj = (lon,lat)=>[ lon*111320*Math.cos(lat*Math.PI/180), lat*110540 ];
    const pts = coords.map(c=>proj(c[0],c[1]));
    const keep=[0, coords.length-1];
    (function rec(a,b){
      let max=0, idx=-1; const [x1,y1]=pts[a], [x2,y2]=pts[b]; const dx=x2-x1, dy=y2-y1; const len2=dx*dx+dy*dy||1e-9;
      for (let i=a+1;i<b;i++){ const [x0,y0]=pts[i]; const t=Math.max(0,Math.min(1,((x0-x1)*dx+(y0-y1)*dy)/len2)); const xn=x1+t*dx, yn=y1+t*dy; const dist=Math.hypot(x0-xn,y0-yn); if(dist>max){max=dist; idx=i;} }
      if (max>eps && idx>0){ rec(a,idx); keep.push(idx); rec(idx,b); }
    })(0, coords.length-1);
    const uniq = Array.from(new Set(keep)).sort((a,b)=>a-b);
    return uniq.map(i=>coords[i]);
  }

  // Nächster Punkt auf gerouteter Linie zu lon/lat
  function nearestOnLine(lineCoords, pt) {
    const proj = (lon,lat)=>[ lon*111320*Math.cos(lat*Math.PI/180), lat*110540 ];
    const [px,py] = proj(pt[0], pt[1]);
    let best=null, bestD=Infinity;

    for (let i=1;i<lineCoords.length;i++){
      const a=lineCoords[i-1], b=lineCoords[i];
      const [ax,ay]=proj(a[0],a[1]), [bx,by]=proj(b[0],b[1]);
      const dx=bx-ax, dy=by-ay, len2=dx*dx+dy*dy||1e-9;
      let t = ((px-ax)*dx + (py-ay)*dy) / len2; t=Math.max(0,Math.min(1,t));
      const xn=ax+t*dx, yn=ay+t*dy;
      const d = Math.hypot(px-xn, py-yn);
      if (d<bestD){ bestD=d; best=[ xn, yn, a, b, t ]; }
    }
    if (!best) return null;

    // un-projizieren per linearer Interpolation zwischen WGS84-Endpunkten
    const [a,b,t] = [best[2], best[3], best[4]];
    const lng = a[0] + t*(b[0]-a[0]);
    const lat = a[1] + t*(b[1]-a[1]);
    return [lng, lat];
  }

  // Startmodus
  setMode('draw');
})();
</script>

{% endblock %}
